/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */,
/* 2 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FLS": () => (/* binding */ FLS),
/* harmony export */   "_slideDown": () => (/* binding */ _slideDown),
/* harmony export */   "_slideToggle": () => (/* binding */ _slideToggle),
/* harmony export */   "_slideUp": () => (/* binding */ _slideUp),
/* harmony export */   "addLoadedClass": () => (/* binding */ addLoadedClass),
/* harmony export */   "addTouchClass": () => (/* binding */ addTouchClass),
/* harmony export */   "bodyLock": () => (/* binding */ bodyLock),
/* harmony export */   "bodyLockStatus": () => (/* binding */ bodyLockStatus),
/* harmony export */   "bodyLockToggle": () => (/* binding */ bodyLockToggle),
/* harmony export */   "bodyUnlock": () => (/* binding */ bodyUnlock),
/* harmony export */   "burger": () => (/* binding */ burger),
/* harmony export */   "dataMediaQueries": () => (/* binding */ dataMediaQueries),
/* harmony export */   "fullVHfix": () => (/* binding */ fullVHfix),
/* harmony export */   "getDigFormat": () => (/* binding */ getDigFormat),
/* harmony export */   "getDigFromString": () => (/* binding */ getDigFromString),
/* harmony export */   "getHash": () => (/* binding */ getHash),
/* harmony export */   "ibg": () => (/* binding */ ibg),
/* harmony export */   "indexInParent": () => (/* binding */ indexInParent),
/* harmony export */   "isMobile": () => (/* binding */ isMobile),
/* harmony export */   "isWebp": () => (/* binding */ isWebp),
/* harmony export */   "menuClose": () => (/* binding */ menuClose),
/* harmony export */   "menuInit": () => (/* binding */ menuInit),
/* harmony export */   "menuOpen": () => (/* binding */ menuOpen),
/* harmony export */   "placeholders": () => (/* binding */ placeholders),
/* harmony export */   "removeClasses": () => (/* binding */ removeClasses),
/* harmony export */   "setHash": () => (/* binding */ setHash),
/* harmony export */   "showMore": () => (/* binding */ showMore),
/* harmony export */   "spollers": () => (/* binding */ spollers),
/* harmony export */   "uniqArray": () => (/* binding */ uniqArray)
/* harmony export */ });
/* harmony import */ var _modules_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);


/* Проверка поддержки webp, добавление класса webp или no-webp для HTML */
function isWebp() {
   // Проверка поддержки webp
   function testWebP(callback) {
      let webP = new Image()
      webP.onload = webP.onerror = function () {
         callback(webP.height == 2)
      }
      webP.src =
         'data:image/webp;base64,UklGRjoAAABXRUJQVlA4IC4AAACyAgCdASoCAAIALmk0mk0iIiIiIgBoSygABc6WWgAA/veff/0PP8bA//LwYAAA'
   }
   // Добавление класса _webp или _no-webp для HTML
   testWebP(function (support) {
      let className = support === true ? 'webp' : 'no-webp'
      document.documentElement.classList.add(className)
   })
}
/* Проверка мобильного браузера */
let isMobile = {
   Android: function () {
      return navigator.userAgent.match(/Android/i)
   },
   BlackBerry: function () {
      return navigator.userAgent.match(/BlackBerry/i)
   },
   iOS: function () {
      return navigator.userAgent.match(/iPhone|iPad|iPod/i)
   },
   Opera: function () {
      return navigator.userAgent.match(/Opera Mini/i)
   },
   Windows: function () {
      return navigator.userAgent.match(/IEMobile/i)
   },
   any: function () {
      return (
         isMobile.Android() ||
         isMobile.BlackBerry() ||
         isMobile.iOS() ||
         isMobile.Opera() ||
         isMobile.Windows()
      )
   }
}
/* Добавление класса touch для HTML если браузер мобильный */
function addTouchClass() {
   // Добавление класса _touch для HTML если браузер мобильный
   if (isMobile.any()) document.documentElement.classList.add('touch')
}
// Добавление loaded для HTML после полной загрузки страницы
function addLoadedClass() {
   window.addEventListener('load', function () {
      setTimeout(function () {
         document.documentElement.classList.add('loaded')
      }, 0)
   })
}
// Получение хеша в адресе сайта
function getHash() {
   if (location.hash) {
      return location.hash.replace('#', '')
   }
}
// Указание хеша в адресе сайта
function setHash(hash) {
   hash = hash ? `#${hash}` : window.location.href.split('#')[0]
   history.pushState('', '', hash)
}
// Учет плавающей панели на мобильных устройствах при 100vh
function fullVHfix() {
   const fullScreens = document.querySelectorAll('[data-fullscreen]')
   if (fullScreens.length && isMobile.any()) {
      window.addEventListener('resize', fixHeight)
      function fixHeight() {
         let vh = window.innerHeight * 0.01
         document.documentElement.style.setProperty('--vh', `${vh}px`)
      }
      fixHeight()
   }
}
// Вспомогательные модули плавного расскрытия и закрытия объекта
let _slideUp = (target, duration = 500, showmore = 0) => {
   if (!target.classList.contains('_slide')) {
      target.classList.add('_slide')
      target.style.transitionProperty = 'height, margin, padding'
      target.style.transitionDuration = duration + 'ms'
      target.style.height = `${target.offsetHeight}px`
      target.offsetHeight
      target.style.overflow = 'hidden'
      target.style.height = showmore ? `${showmore}px` : `0px`
      target.style.paddingTop = 0
      target.style.paddingBottom = 0
      target.style.marginTop = 0
      target.style.marginBottom = 0
      window.setTimeout(() => {
         target.hidden = !showmore ? true : false
         !showmore ? target.style.removeProperty('height') : null
         target.style.removeProperty('padding-top')
         target.style.removeProperty('padding-bottom')
         target.style.removeProperty('margin-top')
         target.style.removeProperty('margin-bottom')
         !showmore ? target.style.removeProperty('overflow') : null
         target.style.removeProperty('transition-duration')
         target.style.removeProperty('transition-property')
         target.classList.remove('_slide')
         // Создаем событие
         document.dispatchEvent(
            new CustomEvent('slideUpDone', {
               detail: {
                  target: target
               }
            })
         )
      }, duration)
   }
}
let _slideDown = (target, duration = 500, showmore = 0) => {
   if (!target.classList.contains('_slide')) {
      target.classList.add('_slide')
      target.hidden = target.hidden ? false : null
      showmore ? target.style.removeProperty('height') : null
      let height = target.offsetHeight
      target.style.overflow = 'hidden'
      target.style.height = showmore ? `${showmore}px` : `0px`
      target.style.paddingTop = 0
      target.style.paddingBottom = 0
      target.style.marginTop = 0
      target.style.marginBottom = 0
      target.offsetHeight
      target.style.transitionProperty = 'height, margin, padding'
      target.style.transitionDuration = duration + 'ms'
      target.style.height = height + 'px'
      target.style.removeProperty('padding-top')
      target.style.removeProperty('padding-bottom')
      target.style.removeProperty('margin-top')
      target.style.removeProperty('margin-bottom')
      window.setTimeout(() => {
         target.style.removeProperty('height')
         target.style.removeProperty('overflow')
         target.style.removeProperty('transition-duration')
         target.style.removeProperty('transition-property')
         target.classList.remove('_slide')
         // Создаем событие
         document.dispatchEvent(
            new CustomEvent('slideDownDone', {
               detail: {
                  target: target
               }
            })
         )
      }, duration)
   }
}
let _slideToggle = (target, duration = 500) => {
   if (target.hidden) {
      return _slideDown(target, duration)
   } else {
      return _slideUp(target, duration)
   }
}
let bodyLockStatus = true
let bodyLockToggle = (delay = 500) => {
   if (document.documentElement.classList.contains('lock')) {
      bodyUnlock(delay)
   } else {
      bodyLock(delay)
   }
}
let bodyUnlock = (delay = 500) => {
   let body = document.querySelector('body')
   if (bodyLockStatus) {
      let lock_padding = document.querySelectorAll('[data-lp]')
      setTimeout(() => {
         for (let index = 0; index < lock_padding.length; index++) {
            const el = lock_padding[index]
            el.style.paddingRight = '0px'
         }
         body.style.paddingRight = '0px'
         document.documentElement.classList.remove('lock')
      }, delay)
      bodyLockStatus = false
      setTimeout(function () {
         bodyLockStatus = true
      }, delay)
   }
}
let bodyLock = (delay = 500) => {
   let body = document.querySelector('body')
   if (bodyLockStatus) {
      let lock_padding = document.querySelectorAll('[data-lp]')
      for (let index = 0; index < lock_padding.length; index++) {
         const el = lock_padding[index]
         el.style.paddingRight =
            window.innerWidth -
            document.querySelector('.wrapper').offsetWidth +
            'px'
      }
      body.style.paddingRight =
         window.innerWidth -
         document.querySelector('.wrapper').offsetWidth +
         'px'
      document.documentElement.classList.add('lock')

      bodyLockStatus = false
      setTimeout(function () {
         bodyLockStatus = true
      }, delay)
   }
}
function spollers() {
   const spollersArray = document.querySelectorAll('[data-spollers]')
   if (spollersArray.length > 0) {
      // Получение обычных слойлеров
      const spollersRegular = Array.from(spollersArray).filter(function (
         item,
         index,
         self
      ) {
         return !item.dataset.spollers.split(',')[0]
      })
      // Инициализация обычных слойлеров
      if (spollersRegular.length) {
         initSpollers(spollersRegular)
      }
      // Получение слойлеров с медиа запросами
      let mdQueriesArray = dataMediaQueries(spollersArray, 'spollers')
      if (mdQueriesArray && mdQueriesArray.length) {
         mdQueriesArray.forEach((mdQueriesItem) => {
            // Событие
            mdQueriesItem.matchMedia.addEventListener(
               'change',
               function () {
                  initSpollers(
                     mdQueriesItem.itemsArray,
                     mdQueriesItem.matchMedia
                  )
               }
            )
            initSpollers(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia)
         })
      }
      // Инициализация
      function initSpollers(spollersArray, matchMedia = false) {
         spollersArray.forEach((spollersBlock) => {
            spollersBlock = matchMedia ? spollersBlock.item : spollersBlock
            if (matchMedia.matches || !matchMedia) {
               spollersBlock.classList.add('_spoller-init')
               initSpollerBody(spollersBlock)
               spollersBlock.addEventListener('click', setSpollerAction)
            } else {
               spollersBlock.classList.remove('_spoller-init')
               initSpollerBody(spollersBlock, false)
               spollersBlock.removeEventListener('click', setSpollerAction)
            }
         })
      }
      // Работа с контентом
      function initSpollerBody(spollersBlock, hideSpollerBody = true) {
         let spollerTitles = spollersBlock.querySelectorAll('[data-spoller]')
         if (spollerTitles.length) {
            spollerTitles = Array.from(spollerTitles).filter(
               (item) => item.closest('[data-spollers]') === spollersBlock
            )
            spollerTitles.forEach((spollerTitle) => {
               if (hideSpollerBody) {
                  spollerTitle.removeAttribute('tabindex')
                  if (
                     !spollerTitle.classList.contains('_spoller-active')
                  ) {
                     spollerTitle.nextElementSibling.hidden = true
                  }
               } else {
                  spollerTitle.setAttribute('tabindex', '-1')
                  spollerTitle.nextElementSibling.hidden = false
               }
            })
         }
      }
      function setSpollerAction(e) {
         const el = e.target
         if (el.closest('[data-spoller]')) {
            const spollerTitle = el.closest('[data-spoller]')
            const spollersBlock = spollerTitle.closest('[data-spollers]')
            const oneSpoller =
               spollersBlock.hasAttribute('data-one-spoller')
            const spollerSpeed = spollersBlock.dataset.spollersSpeed
               ? parseInt(spollersBlock.dataset.spollersSpeed)
               : 500
            if (!spollersBlock.querySelectorAll('._slide').length) {
               if (
                  oneSpoller &&
                  !spollerTitle.classList.contains('_spoller-active')
               ) {
                  hideSpollersBody(spollersBlock)
               }
               spollerTitle.classList.toggle('_spoller-active')
               _slideToggle(spollerTitle.nextElementSibling, spollerSpeed)
            }
            e.preventDefault()
         }
      }
      function hideSpollersBody(spollersBlock) {
         const spollerActiveTitle = spollersBlock.querySelector(
            '[data-spoller]._spoller-active'
         )
         const spollerSpeed = spollersBlock.dataset.spollersSpeed
            ? parseInt(spollersBlock.dataset.spollersSpeed)
            : 500
         if (
            spollerActiveTitle &&
            !spollersBlock.querySelectorAll('._slide').length
         ) {
            spollerActiveTitle.classList.remove('_spoller-active')
            _slideUp(spollerActiveTitle.nextElementSibling, spollerSpeed)
         }
      }
      // Закрытие при клике вне спойлера
      const spollersClose = document.querySelectorAll('[data-spoller-close]')
      if (spollersClose.length) {
         document.addEventListener('click', function (e) {
            const el = e.target
            if (!el.closest('[data-spollers]')) {
               spollersClose.forEach((spollerClose) => {
                  const spollersBlock =
                     spollerClose.closest('[data-spollers]')
                  const spollerSpeed = spollersBlock.dataset.spollersSpeed
                     ? parseInt(spollersBlock.dataset.spollersSpeed)
                     : 500
                  spollerClose.classList.remove('_spoller-active')
                  _slideUp(spollerClose.nextElementSibling, spollerSpeed)
               })
            }
         })
      }
   }
}
function menuInit() {
   if (document.querySelector('.icon-menu')) {
      document.addEventListener('click', function (e) {
         if (bodyLockStatus && e.target.closest('.icon-menu')) {
            bodyLockToggle()
            document.documentElement.classList.toggle('menu-open')
         }
      })
   }
}
function menuOpen() {
   bodyLock()
   document.documentElement.classList.add('menu-open')
}
function menuClose() {
   bodyUnlock()
   document.documentElement.classList.remove('menu-open')
}
function showMore() {
   window.addEventListener('load', function (e) {
      const showMoreBlocks = document.querySelectorAll('[data-showmore]')
      let showMoreBlocksRegular
      let mdQueriesArray
      if (showMoreBlocks.length) {
         // Получение обычных объектов
         showMoreBlocksRegular = Array.from(showMoreBlocks).filter(function (
            item,
            index,
            self
         ) {
            return !item.dataset.showmoreMedia
         })
         // Инициализация обычных объектов
         showMoreBlocksRegular.length
            ? initItems(showMoreBlocksRegular)
            : null

         document.addEventListener('click', showMoreActions)
         window.addEventListener('resize', showMoreActions)

         // Получение объектов с медиа запросами
         mdQueriesArray = dataMediaQueries(showMoreBlocks, 'showmoreMedia')
         if (mdQueriesArray && mdQueriesArray.length) {
            mdQueriesArray.forEach((mdQueriesItem) => {
               // Событие
               mdQueriesItem.matchMedia.addEventListener(
                  'change',
                  function () {
                     initItems(
                        mdQueriesItem.itemsArray,
                        mdQueriesItem.matchMedia
                     )
                  }
               )
            })
            initItemsMedia(mdQueriesArray)
         }
      }
      function initItemsMedia(mdQueriesArray) {
         mdQueriesArray.forEach((mdQueriesItem) => {
            initItems(mdQueriesItem.itemsArray, mdQueriesItem.matchMedia)
         })
      }
      function initItems(showMoreBlocks, matchMedia) {
         showMoreBlocks.forEach((showMoreBlock) => {
            initItem(showMoreBlock, matchMedia)
         })
      }
      function initItem(showMoreBlock, matchMedia = false) {
         showMoreBlock = matchMedia ? showMoreBlock.item : showMoreBlock
         let showMoreContent = showMoreBlock.querySelectorAll(
            '[data-showmore-content]'
         )
         let showMoreButton = showMoreBlock.querySelectorAll(
            '[data-showmore-button]'
         )
         showMoreContent = Array.from(showMoreContent).filter(
            (item) => item.closest('[data-showmore]') === showMoreBlock
         )[0]
         showMoreButton = Array.from(showMoreButton).filter(
            (item) => item.closest('[data-showmore]') === showMoreBlock
         )[0]
         const hiddenHeight = getHeight(showMoreBlock, showMoreContent)
         if (matchMedia.matches || !matchMedia) {
            if (hiddenHeight < getOriginalHeight(showMoreContent)) {
               _slideUp(showMoreContent, 0, hiddenHeight)
               showMoreButton.hidden = false
            } else {
               _slideDown(showMoreContent, 0, hiddenHeight)
               showMoreButton.hidden = true
            }
         } else {
            _slideDown(showMoreContent, 0, hiddenHeight)
            showMoreButton.hidden = true
         }
      }
      function getHeight(showMoreBlock, showMoreContent) {
         let hiddenHeight = 0
         const showMoreType = showMoreBlock.dataset.showmore
            ? showMoreBlock.dataset.showmore
            : 'size'
         if (showMoreType === 'items') {
            const showMoreTypeValue = showMoreContent.dataset
               .showmoreContent
               ? showMoreContent.dataset.showmoreContent
               : 3
            const showMoreItems = showMoreContent.children
            for (let index = 1; index < showMoreItems.length; index++) {
               const showMoreItem = showMoreItems[index - 1]
               hiddenHeight += showMoreItem.offsetHeight
               if (index == showMoreTypeValue) break
            }
         } else {
            const showMoreTypeValue = showMoreContent.dataset
               .showmoreContent
               ? showMoreContent.dataset.showmoreContent
               : 150
            hiddenHeight = showMoreTypeValue
         }
         return hiddenHeight
      }
      function getOriginalHeight(showMoreContent) {
         let parentHidden
         let hiddenHeight = showMoreContent.offsetHeight
         showMoreContent.style.removeProperty('height')
         if (showMoreContent.closest(`[hidden]`)) {
            parentHidden = showMoreContent.closest(`[hidden]`)
            parentHidden.hidden = false
         }
         let originalHeight = showMoreContent.offsetHeight
         parentHidden ? (parentHidden.hidden = true) : null
         showMoreContent.style.height = `${hiddenHeight}px`
         return originalHeight
      }
      function showMoreActions(e) {
         const targetEvent = e.target
         const targetType = e.type
         if (targetType === 'click') {
            if (targetEvent.closest('[data-showmore-button]')) {
               const showMoreButton = targetEvent.closest(
                  '[data-showmore-button]'
               )
               const showMoreBlock =
                  showMoreButton.closest('[data-showmore]')
               const showMoreContent = showMoreBlock.querySelector(
                  '[data-showmore-content]'
               )
               const showMoreSpeed = showMoreBlock.dataset.showmoreButton
                  ? showMoreBlock.dataset.showmoreButton
                  : '500'
               const hiddenHeight = getHeight(
                  showMoreBlock,
                  showMoreContent
               )
               if (!showMoreContent.classList.contains('_slide')) {
                  showMoreBlock.classList.contains('_showmore-active')
                     ? _slideUp(
                        showMoreContent,
                        showMoreSpeed,
                        hiddenHeight
                     )
                     : _slideDown(
                        showMoreContent,
                        showMoreSpeed,
                        hiddenHeight
                     )
                  showMoreBlock.classList.toggle('_showmore-active')
               }
            }
         } else if (targetType === 'resize') {
            showMoreBlocksRegular && showMoreBlocksRegular.length
               ? initItems(showMoreBlocksRegular)
               : null
            mdQueriesArray && mdQueriesArray.length
               ? initItemsMedia(mdQueriesArray)
               : null
         }
      }
   })
}
// FLS (Full Logging System)
function FLS(message) {
   setTimeout(() => {
      if (window.FLS) {
         console.log(message)
      }
   }, 0)
}
// Получить цифры из строки
function getDigFromString(item) {
   return parseInt(item.replace(/[^\d]/g, ''))
}
// Форматирование цифр типа 100 000 000
function getDigFormat(item) {
   return item.toString().replace(/(\d)(?=(\d\d\d)+([^\d]|$))/g, '$1 ')
}
// Убрать класс из всех элементов массива
function removeClasses(array, className) {
   for (var i = 0; i < array.length; i++) {
      array[i].classList.remove(className)
   }
}
// Уникализация массива
function uniqArray(array) {
   return array.filter(function (item, index, self) {
      return self.indexOf(item) === index
   })
}
// Функция получения индекса внутри родителя
function indexInParent(parent, element) {
   const array = Array.prototype.slice.call(parent.children)
   return Array.prototype.indexOf.call(array, element)
}
// Обработа медиа запросов из атрибутов
function dataMediaQueries(array, dataSetValue) {
   // Получение объектов с медиа запросами
   const media = Array.from(array).filter(function (item, index, self) {
      if (item.dataset[dataSetValue]) {
         return item.dataset[dataSetValue].split(',')[0]
      }
   })
   // Инициализация объектов с медиа запросами
   if (media.length) {
      const breakpointsArray = []
      media.forEach((item) => {
         const params = item.dataset[dataSetValue]
         const breakpoint = {}
         const paramsArray = params.split(',')
         breakpoint.value = paramsArray[0]
         breakpoint.type = paramsArray[1] ? paramsArray[1].trim() : 'max'
         breakpoint.item = item
         breakpointsArray.push(breakpoint)
      })
      // Получаем уникальные брейкпоинты
      let mdQueries = breakpointsArray.map(function (item) {
         return (
            '(' +
            item.type +
            '-width: ' +
            item.value +
            'px),' +
            item.value +
            ',' +
            item.type
         )
      })
      mdQueries = uniqArray(mdQueries)
      const mdQueriesArray = []

      if (mdQueries.length) {
         // Работаем с каждым брейкпоинтом
         mdQueries.forEach((breakpoint) => {
            const paramsArray = breakpoint.split(',')
            const mediaBreakpoint = paramsArray[1]
            const mediaType = paramsArray[2]
            const matchMedia = window.matchMedia(paramsArray[0])
            // Объекты с нужными условиями
            const itemsArray = breakpointsArray.filter(function (item) {
               if (
                  item.value === mediaBreakpoint &&
                  item.type === mediaType
               ) {
                  return true
               }
            })
            mdQueriesArray.push({
               itemsArray,
               matchMedia
            })
         })
         return mdQueriesArray
      }
   }
}

//Placeholers
function placeholders() {
   let inputs = document.querySelectorAll('input[data-value],textarea[data-value]');
   inputs_init(inputs);

   function inputs_init(inputs) {
      if (inputs.length > 0) {
         for (let index = 0; index < inputs.length; index++) {
            const input = inputs[index];
            const input_g_value = input.getAttribute('data-value');
            input_placeholder_add(input);
            if (input.value != '' && input.value != input_g_value) {
               input_focus_add(input);
            }
            input.addEventListener('focus', function (e) {
               if (input.value == input_g_value) {
                  input_focus_add(input);
                  input.value = '';
               }
               if (input.getAttribute('data-type') === "pass") {
                  input.setAttribute('type', 'password');
               }
               if (input.classList.contains('_date')) {
                  /*
                  input.classList.add('_mask');
                  Inputmask("99.99.9999", {
                     //"placeholder": '',
                     clearIncomplete: true,
                     clearMaskOnLostFocus: true,
                     onincomplete: function () {
                        input_clear_mask(input, input_g_value);
                     }
                  }).mask(input);
                  */
               }
               if (input.classList.contains('_phone')) {
                  //'+7(999) 999 9999'
                  //'+38(999) 999 9999'
                  //'+375(99)999-99-99'
                  input.classList.add('_mask');
                  Inputmask("+375 (99) 9999999", {
                     //"placeholder": '',
                     clearIncomplete: true,
                     clearMaskOnLostFocus: true,
                     onincomplete: function () {
                        input_clear_mask(input, input_g_value);
                     }
                  }).mask(input);
               }
               if (input.classList.contains('_digital')) {
                  input.classList.add('_mask');
                  Inputmask("9{1,}", {
                     "placeholder": '',
                     clearIncomplete: true,
                     clearMaskOnLostFocus: true,
                     onincomplete: function () {
                        input_clear_mask(input, input_g_value);
                     }
                  }).mask(input);
               }
               form_remove_error(input);
            });
            input.addEventListener('blur', function (e) {
               if (input.value == '') {
                  input.value = input_g_value;
                  input_focus_remove(input);
                  if (input.classList.contains('_mask')) {
                     input_clear_mask(input, input_g_value);
                  }
                  if (input.getAttribute('data-type') === "pass") {
                     input.setAttribute('type', 'text');
                  }
               }
            });
            if (input.classList.contains('_date')) {
               datepicker(input, {
                  customDays: ["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"],
                  customMonths: ["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"],
                  formatter: (input, date, instance) => {
                     const value = date.toLocaleDateString()
                     input.value = value
                  },
                  onSelect: function (input, instance, date) {
                     input_focus_add(input.el);
                  }
               });
            }
         }
      }
   }
   function input_placeholder_add(input) {
      const input_g_value = input.getAttribute('data-value');
      if (input.value == '' && input_g_value != '') {
         input.value = input_g_value;
      }
   }
   function input_focus_add(input) {
      input.classList.add('_focus');
      input.parentElement.classList.add('_focus');
   }
   function input_focus_remove(input) {
      input.classList.remove('_focus');
      input.parentElement.classList.remove('_focus');
   }
   function input_clear_mask(input, input_g_value) {
      input.inputmask.remove();
      input.value = input_g_value;
      input_focus_remove(input);
   }


   let quantityButtons = document.querySelectorAll('.quantity__button');
   if (quantityButtons.length > 0) {
      for (let index = 0; index < quantityButtons.length; index++) {
         const quantityButton = quantityButtons[index];
         quantityButton.addEventListener("click", function (e) {
            let value = parseInt(quantityButton.closest('.quantity').querySelector('input').value);
            if (quantityButton.classList.contains('quantity__button_plus')) {
               value++;
            } else {
               value = value - 1;
               if (value < 1) {
                  value = 1
               }
            }
            quantityButton.closest('.quantity').querySelector('input').value = value;
         });
      }
   }
}
//BURGER//
function burger() {
   const iconMenu = document.querySelector('.icon-menu');
   if (iconMenu) {
      const menuBody = document.querySelector('.menu__body');
      iconMenu.addEventListener('click', function (e) {
         document.body.classList.toggle('_lock');
         iconMenu.classList.toggle('_active');
         menuBody.classList.toggle('_active');
      })
   }
}
//IBG
// ibg
function ibg() {
   let ibg = document.querySelectorAll("._ibg");
   for (var i = 0; i < ibg.length; i++) {
      if (ibg[i].querySelector("img")) {
         ibg[i].style.backgroundImage =
            "url(" + ibg[i].querySelector("img").getAttribute("src") + ")";
      }
   }
   let observer = new MutationObserver((mutationRecords) => {
      mutationRecords.forEach(item => {
         if (item.addedNodes[0]) {
            if (item.addedNodes[0].classList) {
               if (item.addedNodes[0].classList.contains('_ibg')) ibg()
            }
         }
      });
   })
   observer.observe(document.body, {
      childList: true,
      subtree: true,
   });
}


/***/ }),
/* 3 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "mtrModules": () => (/* binding */ mtrModules)
/* harmony export */ });
const mtrModules = {}

/***/ }),
/* 4 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "headerScroll": () => (/* binding */ headerScroll),
/* harmony export */   "pageNavigation": () => (/* binding */ pageNavigation),
/* harmony export */   "stickyBlock": () => (/* binding */ stickyBlock)
/* harmony export */ });
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _gotoblock_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5);

// Модуль прокрутки к блоку

// Переменная контроля добавления события window scroll.
let addWindowScrollEvent = false
//====================================================================================================================================================================================================================================================================================================
// Плавная навигация по странице
function pageNavigation() {
   // data-goto - указать ID блока
   // data-goto-header - учитывать header
   // data-goto-top - недокрутить на указанный размер
   // data-goto-speed - скорость (только если используется доп плагин)
   // Работаем при клике на пункт
   document.addEventListener('click', pageNavigationAction)
   // Если подключен scrollWatcher, подсвечиваем текущий пукт меню
   document.addEventListener('watcherCallback', pageNavigationAction)
   // Основная функция
   function pageNavigationAction(e) {
      if (e.type === 'click') {
         const targetElement = e.target
         if (targetElement.closest('[data-goto]')) {
            const gotoLink = targetElement.closest('[data-goto]')
            const gotoLinkSelector = gotoLink.dataset.goto
               ? gotoLink.dataset.goto
               : ''
            const noHeader = gotoLink.hasAttribute('data-goto-header')
               ? true
               : false
            const gotoSpeed = gotoLink.dataset.gotoSpeed
               ? gotoLink.dataset.gotoSpeed
               : 500
            const offsetTop = gotoLink.dataset.gotoTop
               ? parseInt(gotoLink.dataset.gotoTop)
               : 0
            ;(0,_gotoblock_js__WEBPACK_IMPORTED_MODULE_1__.gotoBlock)(gotoLinkSelector, noHeader, gotoSpeed, offsetTop)
            e.preventDefault()
         }
      } else if (e.type === 'watcherCallback' && e.detail) {
         const entry = e.detail.entry
         const targetElement = entry.target
         // Обработка пунктов навигации, если указано значение navigator подсвечиваем текущий пукт меню
         if (targetElement.dataset.watch === 'navigator') {
            const navigatorActiveItem = document.querySelector(
               `[data-goto]._navigator-active`
            )
            let navigatorCurrentItem
            if (
               targetElement.id &&
               document.querySelector(`[data-goto="#${targetElement.id}"]`)
            ) {
               navigatorCurrentItem = document.querySelector(
                  `[data-goto="#${targetElement.id}"]`
               )
            } else if (targetElement.classList.length) {
               for (
                  let index = 0;
                  index < targetElement.classList.length;
                  index++
               ) {
                  const element = targetElement.classList[index]
                  if (
                     document.querySelector(`[data-goto=".${element}"]`)
                  ) {
                     navigatorCurrentItem = document.querySelector(
                        `[data-goto=".${element}"]`
                     )
                     break
                  }
               }
            }
            if (entry.isIntersecting) {
               // Видим объект
               // navigatorActiveItem ? navigatorActiveItem.classList.remove('_navigator-active') : null;
               navigatorCurrentItem
                  ? navigatorCurrentItem.classList.add(
                     '_navigator-active'
                  )
                  : null
            } else {
               // Не видим объект
               navigatorCurrentItem
                  ? navigatorCurrentItem.classList.remove(
                     '_navigator-active'
                  )
                  : null
            }
         }
      }
   }
   // Прокрутка по хешу
   if ((0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.getHash)()) {
      let goToHash
      if (document.querySelector(`#${(0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.getHash)()}`)) {
         goToHash = `#${(0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.getHash)()}`
      } else if (document.querySelector(`.${(0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.getHash)()}`)) {
         goToHash = `.${(0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.getHash)()}`
      }
      goToHash ? (0,_gotoblock_js__WEBPACK_IMPORTED_MODULE_1__.gotoBlock)(goToHash, true, 500, 20) : null
   }
}
// Работа с шапкой при скроле
function headerScroll() {
   addWindowScrollEvent = true
   const header = document.querySelector('header.header')
   const headerShow = header.hasAttribute('data-scroll-show')
   const headerShowTimer = header.dataset.scrollShow
      ? header.dataset.scrollShow
      : 500
   const startPoint = header.dataset.scroll ? header.dataset.scroll : 1
   let scrollDirection = 0
   let timer
   document.addEventListener('windowScroll', function (e) {
      const scrollTop = window.scrollY
      clearTimeout(timer)
      if (scrollTop >= startPoint) {
         !header.classList.contains('_header-scroll')
            ? header.classList.add('_header-scroll')
            : null
         if (headerShow) {
            if (scrollTop > scrollDirection) {
               // downscroll code
               header.classList.contains('_header-show')
                  ? header.classList.remove('_header-show')
                  : null
            } else {
               // upscroll code
               !header.classList.contains('_header-show')
                  ? header.classList.add('_header-show')
                  : null
            }
            timer = setTimeout(() => {
               !header.classList.contains('_header-show')
                  ? header.classList.add('_header-show')
                  : null
            }, headerShowTimer)
         }
      } else {
         header.classList.contains('_header-scroll')
            ? header.classList.remove('_header-scroll')
            : null
         if (headerShow) {
            header.classList.contains('_header-show')
               ? header.classList.remove('_header-show')
               : null
         }
      }
      scrollDirection = scrollTop <= 0 ? 0 : scrollTop
   })
}
// Прилипающий блок
function stickyBlock() {
   addWindowScrollEvent = true
   // data-sticky для родителя внутри которого прилипает блок *
   // data-sticky-header для родителя, учитываем высоту хедера
   // data-sticky-top="" для родителя, можно указать отступ сверху
   // data-sticky-bottom="" для родителя, можно указать отступ снизу
   // data-sticky-item для прилипающего блока *
   function stickyBlockInit() {
      const stickyParents = document.querySelectorAll('[data-sticky]')
      if (stickyParents.length) {
         stickyParents.forEach((stickyParent) => {
            let stickyConfig = {
               media: stickyParent.dataset.sticky
                  ? parseInt(stickyParent.dataset.sticky)
                  : null,
               top: stickyParent.dataset.stickyTop
                  ? parseInt(stickyParent.dataset.stickyTop)
                  : 0,
               bottom: stickyParent.dataset.stickyBottom
                  ? parseInt(stickyParent.dataset.stickyBottom)
                  : 0,
               header: stickyParent.hasAttribute('data-sticky-header')
                  ? document.querySelector('header.header').offsetHeight
                  : 0
            }
            stickyBlockItem(stickyParent, stickyConfig)
         })
      }
   }
   function stickyBlockItem(stickyParent, stickyConfig) {
      const stickyBlockItem = stickyParent.querySelector('[data-sticky-item]')
      const headerHeight = stickyConfig.header
      const offsetTop = headerHeight + stickyConfig.top
      const startPoint =
         stickyBlockItem.getBoundingClientRect().top + scrollY - offsetTop

      document.addEventListener('windowScroll', stickyBlockActions)
      //window.addEventListener("resize", stickyBlockActions);

      function stickyBlockActions(e) {
         const endPoint =
            stickyParent.offsetHeight +
            stickyParent.getBoundingClientRect().top +
            scrollY -
            (offsetTop + stickyBlockItem.offsetHeight + stickyConfig.bottom)
         let stickyItemValues = {
            position: 'relative',
            bottom: 'auto',
            top: '0px',
            left: '0px',
            width: 'auto'
         }
         if (!stickyConfig.media || stickyConfig.media < window.innerWidth) {
            if (
               offsetTop +
               stickyConfig.bottom +
               stickyBlockItem.offsetHeight <
               window.innerHeight
            ) {
               if (scrollY >= startPoint && scrollY <= endPoint) {
                  stickyItemValues.position = `fixed`
                  stickyItemValues.bottom = `auto`
                  stickyItemValues.top = `${offsetTop}px`
                  stickyItemValues.left = `${stickyBlockItem.getBoundingClientRect().left
                     }px` // Учесть разницу в ширине экрана?
                  stickyItemValues.width = `${stickyBlockItem.offsetWidth}px`
               } else if (scrollY >= endPoint) {
                  stickyItemValues.position = `absolute`
                  stickyItemValues.bottom = `${stickyConfig.bottom}px`
                  stickyItemValues.top = `auto`
                  stickyItemValues.left = `0px`
                  stickyItemValues.width = `${stickyBlockItem.offsetWidth}px`
               }
            }
         }
         stickyBlockType(stickyBlockItem, stickyItemValues)
      }
   }
   function stickyBlockType(stickyBlockItem, stickyItemValues) {
      stickyBlockItem.style.cssText = `position:${stickyItemValues.position};bottom:${stickyItemValues.bottom};top:${stickyItemValues.top};left:${stickyItemValues.left};width:${stickyItemValues.width};`
   }
   stickyBlockInit()
}
// При подключении модуля обработчик события запустится автоматически
setTimeout(() => {
   if (addWindowScrollEvent) {
      let windowScroll = new Event('windowScroll')
      window.addEventListener('scroll', function (e) {
         document.dispatchEvent(windowScroll)
      })
   }
}, 0)

/***/ }),
/* 5 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "gotoBlock": () => (/* binding */ gotoBlock)
/* harmony export */ });
/* harmony import */ var _functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);

// Подключение дополнения для увеличения возможностей
// Документация: https://github.com/cferdinandi/smooth-scroll
// import SmoothScroll from 'smooth-scroll';
//==============================================================================================================================================================================================================================================================================================================================

// Модуль плавной проктутки к блоку
let gotoBlock = (
   targetBlock,
   noHeader = false,
   speed = 500,
   offsetTop = 0
) => {
   const targetBlockElement = document.querySelector(targetBlock)
   if (targetBlockElement) {
      let headerItem = ''
      let headerItemHeight = 0
      if (noHeader) {
         headerItem = 'header.header'
         headerItemHeight = document.querySelector(headerItem).offsetHeight
      }
      let options = {
         speedAsDuration: true,
         speed: speed,
         header: headerItem,
         offset: offsetTop,
         easing: 'easeOutQuad'
      }
      // Закрываем меню, если оно открыто
      document.documentElement.classList.contains('_active')
         ? (0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.menuClose)()
         : null

      if (typeof SmoothScroll !== 'undefined') {
         // Прокрутка с использованием дополнения
         new SmoothScroll().animateScroll(targetBlockElement, '', options)
      } else {
         // Прокрутка стандартными средствами
         let targetBlockElementPosition =
            targetBlockElement.getBoundingClientRect().top + scrollY
         targetBlockElementPosition = headerItemHeight
            ? targetBlockElementPosition - headerItemHeight
            : targetBlockElementPosition
         targetBlockElementPosition = offsetTop
            ? targetBlockElementPosition - offsetTop
            : targetBlockElementPosition
         window.scrollTo({
            top: targetBlockElementPosition,
            behavior: 'smooth'
         })
      }
      (0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.FLS)(`[gotoBlock]: Юхуу...едем к ${targetBlock}`)
   } else {
      (0,_functions_js__WEBPACK_IMPORTED_MODULE_0__.FLS)(`[gotoBlock]: Ой ой..Такого блока нет на странице: ${targetBlock}`)
   }
}


/***/ }),
/* 6 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useDynamicAdapt": () => (/* binding */ useDynamicAdapt)
/* harmony export */ });
/**
 * @typedef {Object} dNode
 * @property {HTMLElement} parent
 * @property {HTMLElement} element
 * @property {HTMLElement} to
 * @property {string} breakpoint
 * @property {string} order
 * @property {number} index
 */

/**
 * @typedef {Object} dMediaQuery
 * @property {string} query
 * @property {number} breakpoint
 */

/**
 * @param {'min' | 'max'} type
 */
function useDynamicAdapt(type = 'max') {
   const className = '_dynamic_adapt_'
   const attrName = 'data-da'

   /** @type {dNode[]} */
   const dNodes = getDNodes()

   /** @type {dMediaQuery[]} */
   const dMediaQueries = getDMediaQueries(dNodes)

   dMediaQueries.forEach((dMediaQuery) => {
      const matchMedia = window.matchMedia(dMediaQuery.query)
      // массив объектов с подходящим брейкпоинтом
      const filteredDNodes = dNodes.filter(({ breakpoint }) => breakpoint === dMediaQuery.breakpoint)
      const mediaHandler = getMediaHandler(matchMedia, filteredDNodes)
      matchMedia.addEventListener('change', mediaHandler)

      mediaHandler()
   })

   function getDNodes() {
      const result = []
      const elements = [...document.querySelectorAll(`[${attrName}]`)]

      elements.forEach((element) => {
         const attr = element.getAttribute(attrName)
         const [toSelector, breakpoint, order] = attr.split(',').map((val) => val.trim())

         const to = document.querySelector(toSelector)

         if (to) {
            result.push({
               parent: element.parentElement,
               element,
               to,
               breakpoint: breakpoint ?? '767',
               order: order !== undefined ? (isNumber(order) ? Number(order) : order) : 'last',
               index: -1,
            })
         }
      })

      return sortDNodes(result)
   }

   /**
    * @param {dNode} items
    * @returns {dMediaQuery[]}
    */
   function getDMediaQueries(items) {
      const uniqItems = [...new Set(items.map(({ breakpoint }) => `(${type}-width: ${breakpoint}px),${breakpoint}`))]

      return uniqItems.map((item) => {
         const [query, breakpoint] = item.split(',')

         return { query, breakpoint }
      })
   }

   /**
    * @param {MediaQueryList} matchMedia
    * @param {dNodes} items
    */
   function getMediaHandler(matchMedia, items) {
      return function mediaHandler() {
         if (matchMedia.matches) {
            items.forEach((item) => {
               moveTo(item)
            })

            items.reverse()
         } else {
            items.forEach((item) => {
               if (item.element.classList.contains(className)) {
                  moveBack(item)
               }
            })

            items.reverse()
         }
      }
   }

   /**
    * @param {dNode} dNode
    */
   function moveTo(dNode) {
      const { to, element, order } = dNode
      dNode.index = getIndexInParent(dNode.element, dNode.element.parentElement)
      element.classList.add(className)

      if (order === 'last' || order >= to.children.length) {
         to.append(element)

         return
      }

      if (order === 'first') {
         to.prepend(element)

         return
      }

      to.children[order].before(element)
   }

   /**
    * @param {dNode} dNode
    */
   function moveBack(dNode) {
      const { parent, element, index } = dNode
      element.classList.remove(className)

      if (index >= 0 && parent.children[index]) {
         parent.children[index].before(element)
      } else {
         parent.append(element)
      }
   }

   /**
    * @param {HTMLElement} element
    * @param {HTMLElement} parent
    */
   function getIndexInParent(element, parent) {
      return [...parent.children].indexOf(element)
   }

   /**
    * Функция сортировки массива по breakpoint и order
    * по возрастанию для type = min
    * по убыванию для type = max
    *
    * @param {dNode[]} items
    */
   function sortDNodes(items) {
      const isMin = type === 'min' ? 1 : 0

      return [...items].sort((a, b) => {
         if (a.breakpoint === b.breakpoint) {
            if (a.order === b.order) {
               return 0
            }

            if (a.order === 'first' || b.order === 'last') {
               return -1 * isMin
            }

            if (a.order === 'last' || b.order === 'first') {
               return 1 * isMin
            }

            return 0
         }

         return (a.breakpoint - b.breakpoint) * isMin
      })
   }

   function isNumber(value) {
      return !isNaN(value)
   }
}
useDynamicAdapt();

/***/ }),
/* 7 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _files_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _files_modules_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);



/*
Предмету, который будет двигаться за мышью указать атрибут data-prlx-mouse.
// =========
Если нужны дополнительные настройки - указать 
Атрибут											Значение по умолчанию
-------------------------------------------------------------------------------------------------------------------
data-prlx-cx="коэффициент_х"					100							значение больше - меньше процент сдвига
data-prlx-cy="коэффициент_y"					100							значение больше - меньше процент сдвига
data-prlx-dxr																		против оси X
data-prlx-dyr																		против оси Y
data-prlx-a="скорость_анимации"				50								больше значение - больше скорость
// =========
Если нужно считывать движение мыши в блоке-родителе - тому родителю указать атрибут data-prlx-mouse-wrapper
Если в параллаксе картинка - расстянуть ее на >100%. 
Например:
   width: 130%;
   height: 130%;
   top: -15%;
   left: -15%;
*/
class MousePRLX {
   constructor(props, data = null) {
      let defaultConfig = {
         init: true,
         logging: true
      }
      this.config = Object.assign(defaultConfig, props)
      if (this.config.init) {
         const paralaxMouse = document.querySelectorAll('[data-prlx-mouse]')
         if (paralaxMouse.length) {
            this.paralaxMouseInit(paralaxMouse)
            this.setLogging(
               `Проснулся, слежу за объектами: (${paralaxMouse.length})`
            )
         } else {
            this.setLogging('Нет ни одного объекта. Сплю...zzZZZzZZz...')
         }
      }
   }
   paralaxMouseInit(paralaxMouse) {
      paralaxMouse.forEach((el) => {
         const paralaxMouseWrapper = el.closest('[data-prlx-mouse-wrapper]')

         // Коэф. X
         const paramСoefficientX = el.dataset.prlxCx
            ? +el.dataset.prlxCx
            : 100
         // Коэф. У
         const paramСoefficientY = el.dataset.prlxCy
            ? +el.dataset.prlxCy
            : 100
         // Напр. Х
         const directionX = el.hasAttribute('data-prlx-dxr') ? -1 : 1
         // Напр. У
         const directionY = el.hasAttribute('data-prlx-dyr') ? -1 : 1
         // Скорость анимации
         const paramAnimation = el.dataset.prlxA ? +el.dataset.prlxA : 50

         // Объявление переменных
         let positionX = 0,
            positionY = 0
         let coordXprocent = 0,
            coordYprocent = 0

         setMouseParallaxStyle()

         // Проверяю на наличие родителя, в котором будет считываться положение мыши
         if (paralaxMouseWrapper) {
            mouseMoveParalax(paralaxMouseWrapper)
         } else {
            mouseMoveParalax()
         }

         function setMouseParallaxStyle() {
            const distX = coordXprocent - positionX
            const distY = coordYprocent - positionY
            positionX = positionX + (distX * paramAnimation) / 1000
            positionY = positionY + (distY * paramAnimation) / 1000
            el.style.cssText = `transform: translate3D(${(directionX * positionX) / (paramСoefficientX / 10)
               }%,${(directionY * positionY) / (paramСoefficientY / 10)}%,0);`
            requestAnimationFrame(setMouseParallaxStyle)
         }
         function mouseMoveParalax(wrapper = window) {
            wrapper.addEventListener('mousemove', function (e) {
               const offsetTop =
                  el.getBoundingClientRect().top + window.scrollY
               if (
                  offsetTop >= window.scrollY ||
                  offsetTop + el.offsetHeight >= window.scrollY
               ) {
                  // Получение ширины и высоты блока
                  const parallaxWidth = window.innerWidth
                  const parallaxHeight = window.innerHeight
                  // Ноль по середине
                  const coordX = e.clientX - parallaxWidth / 2
                  const coordY = e.clientY - parallaxHeight / 2
                  // Получаем проценты
                  coordXprocent = (coordX / parallaxWidth) * 100
                  coordYprocent = (coordY / parallaxHeight) * 100
               }
            })
         }
      })
   }
   // Логгинг в консоль
   setLogging(message) {
      this.config.logging ? (0,_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.FLS)(`[PRLX Mouse]: ${message}`) : null
   }
}
// Запускаем и добавляем в объект модулей
_files_modules_js__WEBPACK_IMPORTED_MODULE_1__.mtrModules.mousePrlx = new MousePRLX({})


/***/ }),
/* 8 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _files_modules_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);


class Parallax {
   constructor(elements) {
      if (elements.length) {
         this.elements = Array.from(elements).map(
            (el) => new Parallax.Each(el, this.options)
         )
      }
   }
   destroyEvents() {
      this.elements.forEach((el) => {
         el.destroyEvents()
      })
   }
   setEvents() {
      this.elements.forEach((el) => {
         el.setEvents()
      })
   }
}

Parallax.Each = class {
   constructor(parent) {
      this.parent = parent
      this.elements = this.parent.querySelectorAll('[data-prlx]')
      this.animation = this.animationFrame.bind(this)
      this.offset = 0
      this.value = 0
      this.smooth = parent.dataset.smooth ? Number(parent.dataset.smooth) : 15
      this.setEvents()
   }
   setEvents() {
      this.animationID = window.requestAnimationFrame(this.animation)
   }
   destroyEvents() {
      window.cancelAnimationFrame(this.animationID)
   }
   animationFrame() {
      const topToWindow = this.parent.getBoundingClientRect().top
      const heightParent = this.parent.offsetHeight
      const heightWindow = window.innerHeight
      const positionParent = {
         top: topToWindow - heightWindow,
         bottom: topToWindow + heightParent
      }
      const centerPoint = this.parent.dataset.center
         ? this.parent.dataset.center
         : 'center'

      if (positionParent.top < 30 && positionParent.bottom > -30) {
         // Элемент в начальном положении (0,0), когда родитель находится по отношению к экрану в:
         switch (centerPoint) {
            // верхней точке (начало родителя соприкачается верхнего края экрана)
            case 'top':
               this.offset = -1 * topToWindow
               break

            // центре экрана (середина родителя в середине экрана)
            case 'center':
               this.offset =
                  heightWindow / 2 - (topToWindow + heightParent / 2)
               break

            // Начало : нижняя часть экрана = верхняя часть родителя
            case 'bottom':
               this.offset = heightWindow - (topToWindow + heightParent)
               break
         }
      }

      this.value += (this.offset - this.value) / this.smooth
      this.animationID = window.requestAnimationFrame(this.animation)

      this.elements.forEach((el) => {
         const parameters = {
            axis: el.dataset.axis ? el.dataset.axis : 'v',
            direction: el.dataset.direction
               ? el.dataset.direction + '1'
               : '-1',
            coefficient: el.dataset.coefficient
               ? Number(el.dataset.coefficient)
               : 5,
            additionalProperties: el.dataset.properties
               ? el.dataset.properties
               : ''
         }
         this.parameters(el, parameters)
      })
   }
   parameters(el, parameters) {
      if (parameters.axis == 'v') {
         el.style.transform = `translate3D(0, ${(
            parameters.direction *
            (this.value / parameters.coefficient)
         ).toFixed(2)}px,0) ${parameters.additionalProperties}`
      } else if (parameters.axis == 'h') {
         el.style.transform = `translate3D(${(
            parameters.direction *
            (this.value / parameters.coefficient)
         ).toFixed(2)}px,0,0) ${parameters.additionalProperties}`
      }
   }
}

if (document.querySelectorAll('[data-prlx-parent]')) {
   _files_modules_js__WEBPACK_IMPORTED_MODULE_0__.mtrModules.parallax = new Parallax(
      document.querySelectorAll('[data-prlx-parent]')
   )
}

/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.
(() => {
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _files_functions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
/* harmony import */ var _files_scroll_scroll_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _libs_dynamic_adapt_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6);
/* harmony import */ var _libs_paralax_mouse_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(7);
/* harmony import */ var _libs_parallax_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);

_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.isWebp()
_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.burger()
_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.spollers()
_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.placeholders()
_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.ibg()
_files_functions_js__WEBPACK_IMPORTED_MODULE_0__.spollers()

;
_files_scroll_scroll_js__WEBPACK_IMPORTED_MODULE_1__.headerScroll();










})();

/******/ })()
;